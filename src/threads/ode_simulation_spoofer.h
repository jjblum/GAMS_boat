
#ifndef   _THREAD_ODE_SIM_SPOOFER_H_
#define   _THREAD_ODE_SIM_SPOOFER_H_

#include <string>
#include <vector>
#include <cmath>
#include <iostream>
#include <eigen3/Eigen/Core>
#include <GeographicLib/GeoCoords.hpp>
#include <boost/numeric/odeint.hpp>

#include "madara/threads/BaseThread.h"
#include "localization.h"
#include "../boat_containers.h"
#include "../datum.h"
#include "../utility.h"
#include "../localization_caller.h"
#include "../design.h"

//typedef boost::array< double , STATE_DIMENSION > state_array_type; // for use with odeint
#define WATER_KG_PER_SQ_M 1000.0

static double _ODE_MASS;
static double _ODE_MOMENT_OF_INERTIA;
static double _ODE_THRUST_SURGE;
static double _ODE_THRUST_SWAY;
static double _ODE_MOMENT;
static double _ODE_DRAG_AREA_SURGE;
static double _ODE_DRAG_AREA_SWAY;
static double _ODE_DRAG_AREA_TURN;
static double _ODE_DRAG_COEFF_SURGE;
static double _ODE_DRAG_COEFF_SWAY;
static double _ODE_DRAG_COEFF_TURN;

void boat_ode (const std::vector<double> &x, std::vector<double> &dxdt, double t_); 

namespace threads
{
  /**
  * A custom thread generated by gams_sim_conf.pl
  **/
  class ODE_sim_spoofer : public madara::threads::BaseThread, public LocalizationCaller
  {
  public:
    /**
     * Default constructor
     **/
    ODE_sim_spoofer (Containers containers_, std::shared_ptr<designs::Design> design_, threads::localization * localization_reference);
    
    /**
     * Destructor
     **/
    virtual ~ODE_sim_spoofer ();
    
    /**
      * Initializes thread with MADARA context
      * @param   context   context for querying current program state
      **/
    virtual void init (madara::knowledge::KnowledgeBase & knowledge);

    /**
      * Executes the main thread logic
      **/
    virtual void run (void);
    
    //static void boat_ode(const std::vector<double> &x, std::vector<double> &dxdt, double t);

  private:
    /// data plane if we want to access the knowledge base
    madara::knowledge::KnowledgeBase data_;
    Containers containers;
    std::shared_ptr<designs::Design> design;
    std::chrono::time_point<std::chrono::high_resolution_clock> t;
    double t_double;
    double t_to_gps;
    double t_to_ahrs;
    std::vector<double> state;
    std::vector<double> motor_signals;
    std::vector<double> thrust_and_moment;
    boost::numeric::odeint::runge_kutta4< std::vector<double> > rk;
  };
} // end namespace threads

#endif // _THREAD_ODE_SIM_SPOOFER_H_
